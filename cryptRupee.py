
import hashlib
import json
import requests
from time import time
from uuid import uuid4
from textwrap import dedent
from flask import Flask, jsonify, request
from urllib.parse import urlparse


class cryptRupee(object):
    def __init__(self):
        self.blockchain = []
        self.transactions = []

        # Creation of the mentioned genesis block
        self.create_new_block(previous_hash=1, proof=100)

        self.nodes = set()

    def create_new_block(self, proof, previous_hash=None):
        """
        Creates a new block and adds it to the blockchain
        :param proof: <int> This is generated by the proof of work algorithm
        :param previous_hash: (Optional) <str> Hash of the preleading Block
        :return: <dict> Return the new block
        """

        new_block = {
            'index': len(self.blockchain) + 1,
            'timestamp': time(),
            'transactions': self.transactions,
            'proof': proof,
            'previous_hash': previous_hash or self.hash(self.blockchain[-1]),
        }

        # As all pending transactions have been processed and added to the block, the list can be resetted
        self.transactions = []

        # Add the new block to the blockchain
        self.blockchain.append(new_block)
        return new_block

    def create_new_transaction(self, sender, recipient, amount):
        """
        This function creates a new transaction that will then be placed in a new block, alone or bundled together with other transactions.

        :param sender: <str> Sender's address
        :param recipient: <str> Recipient's address
        :param amount: <int> Amount to be transferred
        :return: <int> This is the index of the block that will contain this transaction
        """

        self.transactions.append({
            'sender': sender,
            'recipient': recipient,
            'amount': amount,
        })

        return self.last_block['index'] + 1

    @staticmethod
    def hash(block):
        """
        This function hashes the block using the SHA-256 hash algorithm
        The function is given a block and returns a string, consisting of the hash
        :param block: <dict> Block
        :return: <str>
        """

        # As every change in an item changes the hash, we first have to do a little sort operation, or else we would get inconsistent hashes
        block_sorted = json.dumps(block, sort_keys=True).encode()
        return hashlib.sha256(block_sorted).hexdigest()

    @property
    def last_block(self):
        return self.blockchain[-1]

    def pow(self, last_proof):
        """
        Simple PoW Algorithm:
         - Find a number y, so that hash(xy) starts with 5 zeroes. x is the last y aka last_proof. y is then the new proof.
        :param last_proof: <int>
        :return: <int>
        """

        current_proof = 0
        while self.validate_proof(last_proof, current_proof) is False:
            current_proof += 1

        return current_proof

    @staticmethod
    def validate_proof(last_proof, current_proof):
        """
        Returns, whether the hash of the lastproof and the current_proof contains 5 leading zeroes.
        :param last_proof: <int> Previous Proof Number
        :param current_proof: <int> Current Proof Number
        :return: <bool>
        """

        possible_hash = hashlib.sha256(f'{last_proof}{current_proof}'.encode()).hexdigest()
        return possible_hash[:5] == "00000"

    def add_node(self, address):
        """
        Register a new node
        :param address: <str> This is the new node's address, for example 'http://192.168.1.112:5000'
        :return: None
        """

        node_url = urlparse(address)
        self.nodes.add(node_url.netloc)

    def validate_blockchain(self, test_chain):
        """
        Evaluate, whether a blockchain is valid
        :param chain: <list> The blockchain that shall be tested
        :return: <bool> Returns true if the blockchain is valid
        """

        last_block = test_chain[0]
        current_index = 1

        while current_index < len(test_chain):
            block = test_chain[current_index]

            # Determine, whether the hash is correct
            if block['previous_hash'] != self.hash(last_block):
                return False

            # Determine, wheter the proof of work is correct
            if not self.validate_proof(last_block['proof'], block['proof']):
                return False

            last_block = block
            current_index += 1

        return True

    def resolve(self):
        """
        This algorithm resolves conflicts between our nodes. It is the consensus algorithm which I mentioned previously.
        :return: <bool> Returns true, if our chain was substituted with an updated version
        """

        surrounding_nodes = self.nodes
        updated_chain = None

        # If we follow our consensus algorithm description, we only want blockchains that are longer, than our current chain
        max_length = len(self.blockchain)

        # Iterate every surrounding nodes in our network through the consensus algorithm, which means checking if the node's blockchain is longer than our current blockchain and valid and set it as our new blockchain and continue checking, as there could be an even longer and valid blockchain.
        for node_iterator in surrounding_nodes:
            response = requests.get(f'http://{node_iterator}/blockchain')

            if response.status_code == 200:
                length = response.json()['length']
                chain_iterator = response.json()['chain']

                if length > max_length and self.validate_blockchain(chain_iterator):
                    max_length = length
                    updated_chain = chain_iterator

        # If we found a new blockchain, replace our current blockchain with the new one
        if updated_chain:
            self.blockchain = updated_chain
            return True

        return False


app = Flask(__name__)
node_identifier = str(uuid4()).replace('-', '')

merablockchain = cryptRupee()


@app.route('/blockchain', methods=['GET'])
def get_full_chain():
    output = {
        'chain': merablockchain.blockchain,
        'length': len(merablockchain.blockchain),
    }
    return jsonify(output), 200


@app.route('/mining', methods=['GET'])
def mining():
    # Calculate the new proof by using our PoW algorithm
    last_block = merablockchain.last_block
    last_proof = last_block['proof']
    proof = merablockchain.pow(last_proof)

    # For finding/mining the proof, the miner is granted a reward
    # The sender is nobody, as this coin is coming out of the void
    merablockchain.create_new_transaction(
        sender="0",
        recipient=node_identifier,
        amount=1,
    )

    # Add the new created block to the chain
    previous_hash = merablockchain.hash(last_block)
    newblock = merablockchain.create_new_block(proof, previous_hash)

    output = {
        'message': "A new block was mined",
        'index': newblock['index'],
        'transactions': newblock['transactions'],
        'proof': newblock['proof'],
        'previous_hash': newblock['previous_hash'],
    }
    return jsonify(output), 200


@app.route('/transactions/add', methods=['POST'])
def add_transaction():
    values = request.get_json()

    # The POST request has to have the following required fields
    required = ['sender', 'recipient', 'amount']
    if not all(k in values for k in required):
        return 'There are values missing', 400

    # Adds a new transaction by utilizing our function
    index = merablockchain.create_new_transaction(values['sender'], values['recipient'], values['amount'])

    output = {'message': f'Your registered Transaction is going to be a part of the block with the index of {index}'}
    return jsonify(output), 201


@app.route('/nodes/add', methods=['POST'])
def add_nodes():
    values = request.get_json()

    nodes = values.get('nodes')
    if nodes is None:
        return "You didn't post a valid list of nodes. Please double check your input!", 400

    for node in nodes:
        merablockchain.add_node(node)

    response = {
        'message': 'All of your specified nodes have been added to the network!',
        'total_nodes': list(merablockchain.nodes),
    }
    return jsonify(response), 201


@app.route('/nodes/resolve', methods=['GET'])
def consensus():
    replaced = merablockchain.resolve()

    if replaced:
        response = {
            'message': 'There was a longer valid chain within the network. The blockchain of this node has been replaced.',
            'new_chain': merablockchain.blockchain
        }
    else:
        response = {
            'message': 'The blockchain of this node is already the longest valid chain within the network.',
            'chain': merablockchain.blockchain
        }

    return jsonify(response), 200


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)